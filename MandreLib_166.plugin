"""
╭─────────────────────────────────────────────────────────────╮
│                                                             │
│  ███╗   ███╗ █████╗ ███╗   ██╗██████╗ ██████╗ ███████╗      │
│  ████╗ ████║██╔══██╗████╗  ██║██╔══██╗██╔══██╗██╔════╝      │
│  ██╔████╔██║███████║██╔██╗ ██║██║  ██║██████╔╝█████╗        │
│  ██║╚██╔╝██║██╔══██║██║╚██╗██║██║  ██║██╔══██╗██╔══╝        │
│  ██║ ╚═╝ ██║██║  ██║██║ ╚████║██████╔╝██║  ██║███████╗      │
│  ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝ ╚═╝  ╚═╝╚══════╝      │
│                                                             │
│         █████╗ ██╗                                          │
│        ██╔══██╗██║    ╭───────────────────╮                 │
│        ███████║██║    │© 2024-2025        │                 │
│        ██╔══██║██║    │Licensed Product   │                 │
│        ██║  ██║██║    │All Rights Reserved│                 │
│        ╚═╝  ╚═╝╚═╝    ╰───────────────────╯                 │
│                                                             │
│  ╭───────────────────────────────────────────────────────╮  │
│  │ Unauthorized use, reproduction or distribution        │  │
│  │ of this software is strictly prohibited               │  │
│  ╰───────────────────────────────────────────────────────╯  │
│                                                             │
╰─────────────────────────────────────────────────────────────╯
"""
#    /\_/\
#   ( o.o )
#    > ^ <
# Этот котик проверил код, и он идеален. Мяу!
# кангелочек Я И ЕСТЬ ИНТЕРНЕТ АНГЕЛ УВЕРЯЮ...... кангел это чеп такое? братан я ввижу внизу кастыль n\n\  а не проще просто """  текст """  ?!?!?
__id__ = "mandre_lib"
__name__ = "MandreLib"
__version__ = "1.6.6"
__author__ = """MandreAI & СвагаНеТута
@swagnonher & @MandreAI_bot"""
__description__ = "Бибилотека для создания плагинов \n\n Документация: https://manderelib.vercel.app/"
__min_version__ = "11.9.0"
__icon__ = "DoubtfulCoffeeTurkey_by_fStikBot/12"

# --- Импорты ---
import traceback
import time
import threading
import os
import json
import zipfile
import requests
import re
import sys
import io
import shlex
import types
from datetime import datetime
from typing import Callable, List, Optional, Dict, Any

from base_plugin import BasePlugin, MethodHook, HookResult, HookStrategy
from client_utils import get_last_fragment, get_messages_controller, get_user_config, run_on_queue, get_messages_storage, get_send_messages_helper
from android_utils import run_on_ui_thread, log, OnClickListener
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from ui.settings import Header, Text, Divider, Input
from hook_utils import find_class, get_private_field

# Импорты для UI, хуков и эффектов
from org.telegram.tgnet import TLRPC
from org.telegram.messenger import AndroidUtilities, ApplicationLoader, LocaleController, R
from org.telegram.ui.Components import AvatarDrawable, BackupImageView, RecyclerListView
from org.telegram.ui.ActionBar import Theme
from android.widget import LinearLayout, EditText, ScrollView, TextView, ImageView, FrameLayout
from android.view import View, Gravity
from android.text import TextWatcher, TextUtils
from android.os import Handler, Looper, Build, VibrationEffect, Bundle, Environment
from android.telephony import TelephonyManager
from android.app import Activity
from android.content import Intent, Context
from android.net import Uri
from androidx.core.content import FileProvider
from androidx.core.app import NotificationCompat, NotificationManagerCompat, Person
from hook_utils import find_class
from java.io import File, FileOutputStream
from java import dynamic_proxy
from java.lang import Runnable, Float as JFloat, Class as JClass, Integer as JInteger
from java.lang import Runnable as JRunnable
from java.util import ArrayList, Locale, TimeZone
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity
from android.graphics import Color, Bitmap, Canvas, Paint, PorterDuff, PorterDuffXfermode, Rect, RectF, BitmapFactory
from android.graphics.drawable import GradientDrawable, ColorDrawable
from android.animation import ObjectAnimator
from android.view.animation import DecelerateInterpolator

# --- Новые импорты для TTS, аутентификации и уведомлений ---
try:
    TextToSpeech = find_class("android.speech.tts.TextToSpeech")
    KeyguardManager = find_class("android.app.KeyguardManager")
    # Уведомления
    NotificationChannel = find_class("android.app.NotificationChannel")
    NotificationManager = find_class("android.app.NotificationManager")
    PendingIntent = find_class("android.app.PendingIntent")
    IconCompat = find_class("androidx.core.graphics.drawable.IconCompat")
    
    JAVA_EXT_CLASSES_FOUND = True
except Exception:
    JAVA_EXT_CLASSES_FOUND = False
# ----------------------------------------


# --- Глобальные переменные для библиотеки ---
_TG_ALIAS_MAP = {}
_tg_hook_installed = False
_make_ripple_method = None

_TASK_LOCK = threading.Lock()
_TASKS = {}
_RUNNING_TASKS = set()
_SCHEDULER_HANDLER = Handler(Looper.getMainLooper())
_SCHEDULER_RUNNABLE = None

_DATA_LOCK = threading.Lock()
_PERSISTENT_PLUGINS = set()
_RESTORING_PLUGINS = set()

_BOTTOM_BAR_CONFIGS = {}
_bottom_bar_hooks_installed = False

_COMMAND_LOCK = threading.Lock()
_COMMANDS = {}
_mandrelib_instance = None

_LOCALIZATIONS = {}
_LOCALIZATION_CACHE = {}

FILE_PICK_REQUEST_CODE = 42069

# --- Новые глобальные переменные ---
_AUTH_REQUEST_CODE = 1337
_auth_hook = None
_auth_success_cb = None
_auth_failure_cb = None

# ---- MandreLib PIP: bootstrap and install pure Python wheels (none-any) ----
WHEELS_PIP_CORE = {
    "setuptools": "https://files.pythonhosted.org/packages/a3/dc/17031897dae0efacfea57dfd3a82fdd2a2aeb58e0ff71b77b87e44edc772/setuptools-80.9.0-py3-none-any.whl",
    "pip": "https://files.pythonhosted.org/packages/44/3c/d717024885424591d5376220b5e836c2d5293ce2011523c9de23ff7bf068/pip-25.3-py3-none-any.whl",
    "wheel": "https://files.pythonhosted.org/packages/0b/2c/87f3254fd8ffd29e4c02732eee68a83a1d3c346ae39bc6822dcbcb697f2b/wheel-0.45.1-py3-none-any.whl",
}

class _IOCapture:
    def __init__(self):
        self.stdout_buf = io.StringIO()
        self.stderr_buf = io.StringIO()
        self._old_out = None
        self._old_err = None
    def __enter__(self):
        self._old_out, self._old_err = sys.stdout, sys.stderr
        sys.stdout, sys.stderr = self.stdout_buf, self.stderr_buf
        return self
    def __exit__(self, exc_type, exc, tb):
        sys.stdout, sys.stderr = self._old_out, self._old_err
    def getvalue(self):
        return self.stdout_buf.getvalue(), self.stderr_buf.getvalue()

def _mandrelib_get_pip_dirs():
    try:
        app_files = str(ApplicationLoader.getFilesDirFixed())
    except Exception:
        try:
            app_files = str(ApplicationLoader.applicationContext.getFilesDir())
        except Exception:
            app_files = "."
    base_dir = os.path.join(app_files, "mandre_pip")
    wheel_dir = os.path.join(base_dir, "wheels")
    site_dir = os.path.join(base_dir, "site-packages")
    log_file = os.path.join(base_dir, "pip.log")
    for p in [base_dir, wheel_dir, site_dir]:
        try:
            os.makedirs(p, exist_ok=True)
        except Exception:
            pass
    return base_dir, wheel_dir, site_dir, log_file

def _mandrelib_log_pip(msg: str):
    try:
        _, _, _, log_file = _mandrelib_get_pip_dirs()
        line = f"[MandreLib PIP] {msg}"
        log(line)
        with open(log_file, "a", encoding="utf-8") as f:
            f.write(line + "\n")
    except Exception:
        pass

def _mandrelib_ensure_site_on_path(site_dir: str):
    if site_dir not in sys.path:
        sys.path.insert(0, site_dir)
        _mandrelib_log_pip(f"sys.path += {site_dir}")

def _mandrelib_bootstrap_pip() -> bool:
    try:
        import pip  # noqa: F401
        _mandrelib_log_pip("pip already importable")
        return True
    except Exception:
        _mandrelib_log_pip("pip not importable: bootstrapping from wheels")
    _, wheel_dir, site_dir, _ = _mandrelib_get_pip_dirs()
    # Download wheels
    for name, url in WHEELS_PIP_CORE.items():
        try:
            fname = os.path.join(wheel_dir, url.split("/")[-1])
            if not os.path.exists(fname) or os.path.getsize(fname) == 0:
                _mandrelib_log_pip(f"Downloading {name} from {url}")
                r = requests.get(url, timeout=30)
                r.raise_for_status()
                with open(fname, "wb") as f:
                    f.write(r.content)
                _mandrelib_log_pip("Saved %s -> %s (%d bytes)" % (name, fname, len(r.content)))
            else:
                _mandrelib_log_pip("Using cached wheel: %s" % fname)
        except Exception as e:
            _mandrelib_log_pip("ERROR download %s: %s" % (name, e))
            return False
    # Extract to site-packages
    try:
        for f in os.listdir(wheel_dir):
            if f.endswith(".whl"):
                whl_path = os.path.join(wheel_dir, f)
                _mandrelib_log_pip("Extracting %s -> %s" % (whl_path, site_dir))
                with zipfile.ZipFile(whl_path) as zf:
                    zf.extractall(site_dir)
        _mandrelib_ensure_site_on_path(site_dir)
        import importlib
        importlib.invalidate_caches()
        import pip  # noqa: F401
        _mandrelib_log_pip("pip import OK after extraction")
        return True
    except Exception as e:
        _mandrelib_log_pip("ERROR extract/import pip: %s" % e)
        return False

def _mandrelib_pip_main(argv):
    try:
        from pip._internal.cli.main import main as pip_main
    except Exception:
        try:
            import pip
            pip_main = getattr(pip, "main", None)
        except Exception:
            pip_main = None
    if pip_main is None:
        return 1, "", "pip main not found"
    _mandrelib_log_pip("pip argv: %s" % (argv,))
    with _IOCapture() as cap:
        code = 0
        try:
            code = pip_main(argv)
        except BaseException as be:
            code = getattr(be, "code", 1) if isinstance(be, SystemExit) else 1
        out, err = cap.getvalue()
    if code is None:
        code = 0
    _mandrelib_log_pip("pip exit=%s\nSTDOUT:\n%s\nSTDERR:\n%s" % (code, out, err))
    return code, out, err

def _mandrelib_pip_normalize(argv: list, site_dir: str, settings_getter) -> list:
    if not argv:
        return ["help"]
    argv = list(argv)
    cmd = argv[0]
    rest = argv[1:]
    flags = []
    try:
        if settings_getter("pip_quiet", False):
            flags += ["-q"]
        idx = settings_getter("pip_index_url", "").strip()
        if idx:
            flags += ["--index-url", idx]
        extra = settings_getter("pip_extra_index_url", "").strip()
        if extra:
            for u in re.split(r"[\s,]+", extra):
                if u:
                    flags += ["--extra-index-url", u]
        trusted = settings_getter("pip_trusted_hosts", "").strip()
        if trusted:
            for h in re.split(r"[\s,]+", trusted):
                if h:
                    flags += ["--trusted-host", h]
        proxy = settings_getter("pip_proxy", "").strip()
        if proxy:
            flags += ["--proxy", proxy]
    except Exception:
        pass
    if cmd == "install":
        has_target = any(a in ("-t", "--target") for a in rest)
        if not has_target:
            rest = ["--target", site_dir] + rest
        prefer_binary = settings_getter("pip_prefer_binary", True)
        force_binary = settings_getter("pip_force_binary", True)
        if force_binary:
            rest = ["--only-binary", ":all:"] + rest
        elif prefer_binary:
            rest = ["--prefer-binary"] + rest
        if settings_getter("pip_no_build_isolation", True):
            rest = ["--no-build-isolation"] + rest
        if settings_getter("pip_upgrade", True):
            rest = ["--upgrade"] + rest
        # Reduce pip conflict scanning errors in Android env
        rest = ["--no-warn-conflicts"] + rest
    return [cmd] + flags + rest

class MandrePip:
    @staticmethod
    def ensure_ready() -> bool:
        _, _, site_dir, _ = _mandrelib_get_pip_dirs()
        _mandrelib_ensure_site_on_path(site_dir)
        ok = _mandrelib_bootstrap_pip()
        try:
            if ok:
                BulletinHelper.show_success("MandreLib: pip готов", get_last_fragment())
            else:
                BulletinHelper.show_error("MandreLib: не удалось инициализировать pip", get_last_fragment())
        except Exception:
            pass
        return ok

    @staticmethod
    def pip(args) -> tuple:
        if isinstance(args, str):
            try:
                args = shlex.split(args)
            except Exception:
                args = args.split()
        _, _, site_dir, _ = _mandrelib_get_pip_dirs()
        _mandrelib_ensure_site_on_path(site_dir)
        if not _mandrelib_bootstrap_pip():
            return 1, "", "bootstrap failed"
        normalized = _mandrelib_pip_normalize(args, site_dir, lambda k, d=None: _mandrelib_instance.get_setting(k, d) if _mandrelib_instance else d)
        return _mandrelib_pip_main(normalized)

    @staticmethod
    def install(spec: str) -> tuple:
        return MandrePip.pip(["install", spec])

    @staticmethod
    def site_dir() -> str:
        return _mandrelib_get_pip_dirs()[2]

    @staticmethod
    def import_module(mod: str):
        _ = MandrePip.ensure_ready()
        _mandrelib_ensure_site_on_path(MandrePip.site_dir())
        return __import__(mod)

class MandreInstall:
    """Tiny helper to install one or many none-any packages with a single call.
    Usage: MandreInstall(["pyrogram", "typing_extensions"]).
    """
    def __init__(self, specs):
        try:
            if isinstance(specs, (list, tuple)):
                for s in specs:
                    try:
                        MandrePip.import_module(s)
                        continue
                    except Exception:
                        pass
                    try:
                        MandrePip.install(str(s))
                    except Exception:
                        pass
            elif isinstance(specs, str):
                try:
                    MandrePip.import_module(specs)
                except Exception:
                    MandrePip.install(specs)
        except Exception:
            pass

class MandreWeb:
    @staticmethod
    def render_html_to_png(html: str,
                           on_result: Callable[[bool, str], None],
                           width: int = 1024,
                           height: int = 768,
                           base_url: str = "about:blank",
                           capture_delays_ms: list = None,
                           bg_color: tuple = (26, 30, 36),
                           file_prefix: str = "mandre_web_"):
        if capture_delays_ms is None:
            capture_delays_ms = [900, 1500, 2200]
        def ui_runner():
            try:
                fragment = get_last_fragment()
                activity = fragment.getParentActivity() if fragment else None
                if not activity:
                    try: on_result(False, "no_activity")
                    except Exception: pass
                    return
                from android.webkit import WebView, WebViewClient
                from android.view import View
                from android.os import Handler, Looper
                from android.graphics import Bitmap, Canvas
                # Prepare WebView
                wv = WebView(activity)
                settings = wv.getSettings()
                try:
                    settings.setJavaScriptEnabled(True)
                    settings.setDomStorageEnabled(True)
                    settings.setLoadsImagesAutomatically(True)
                except Exception:
                    pass
                # Size offscreen
                MS = View.MeasureSpec
                wv.measure(MS.makeMeasureSpec(width, MS.EXACTLY), MS.makeMeasureSpec(height, MS.EXACTLY))
                wv.layout(0, 0, width, height)
                # BG color
                try:
                    from android.graphics import Color
                    wv.setBackgroundColor(Color.argb(255, *bg_color))
                except Exception:
                    pass
                # Load content
                wv.setWebViewClient(WebViewClient())
                wv.loadDataWithBaseURL(base_url, html, "text/html", "utf-8", None)
                # Output path
                cache_dir = ApplicationLoader.applicationContext.getCacheDir()
                ts = int(time.time() * 1000)
                out_path = os.path.join(str(cache_dir), f"{file_prefix}{ts}.png")
                result_flag = {"ok": False}

                def capture_once():
                    try:
                        bmp = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
                        canvas = Canvas(bmp)
                        wv.draw(canvas)
                        # Save
                        fos = FileOutputStream(out_path)
                        try:
                            bmp.compress(Bitmap.CompressFormat.PNG, 100, fos)
                        finally:
                            try: fos.close()
                            except Exception: pass
                        result_flag["ok"] = True
                        try: on_result(True, out_path)
                        except Exception: pass
                    except Exception as e:
                        log(f"[MandreWeb] capture error: {e}")

                class _Run(dynamic_proxy(JRunnable)):
                    def run(self_inner):
                        if not result_flag["ok"]:
                            capture_once()

                h = Handler(Looper.getMainLooper())
                for d in capture_delays_ms:
                    h.postDelayed(_Run(), int(d))
            except Exception as e:
                log(f"[MandreWeb] flow error: {e}")
                try: on_result(False, str(e))
                except Exception: pass
        run_on_ui_thread(ui_runner)

class MandreSend:
    @staticmethod
    def png(path: str, caption: str = None):
        try:
            fragment = get_last_fragment()
            account = fragment.getCurrentAccount() if fragment else 0
            dialog_id = fragment.getDialogId() if fragment else 0
            from org.telegram.messenger import SendMessagesHelper, AccountInstance
            # Try photo first
            try:
                send_helper = get_send_messages_helper()
                generated = send_helper.generatePhotoSizes(path, None)
            except Exception:
                generated = None
            if generated is not None:
                params = SendMessagesHelper.SendMessageParams.of(
                    generated, None, dialog_id, None, None,
                    caption or "", None, None, None, True, 0, 0, None, False
                )
                try:
                    # Some builds require AccountInstance instead of int
                    inst = AccountInstance.getInstance(account)
                    SendMessagesHelper.getInstance(inst).sendMessage(params)
                except Exception:
                    # Fallback to int-based overload if available
                    SendMessagesHelper.getInstance(account).sendMessage(params)
            else:
                SendMessagesHelper.prepareSendingDocument(
                    account, path, path, None, caption or "", "image/png",
                    dialog_id, None, None, None, None, None, True, 0, None, None, 0, False
                )
        except Exception as e:
            log(f"[MandreSend] send error: {e}")

class _TTSState:
    tts = None
    init_ok = False
    engine = None
    deferred = False
_TTS_STATE = _TTSState()
GOOGLE_TTS_PKG = "com.google.android.tts"
# ----------------------------------------

class _TGIntentHook(MethodHook):
    def before_hooked_method(self, param):
        try:
            if not _TG_ALIAS_MAP or not param.args or len(param.args) < 1: return
            intent = param.args[0]
            if not intent: return
            data = intent.getData()
            if not data: return
            url = str(data.toString())
            if not url.startswith("tg://"): return
            path = url[5:].lstrip('/')
            for alias, cb in list(_TG_ALIAS_MAP.items()):
                if path.startswith(alias):
                    log(f"[MandreLib] Перехвачен tg:// алиас: '{alias}'")
                    run_on_ui_thread(lambda: cb(intent))
                    param.setResult(True)
                    return
        except Exception: log(f"[MandreLib] Ошибка в _TGIntentHook: {traceback.format_exc()}")

def _ensure_tg_hook(plugin_self: BasePlugin):
    global _tg_hook_installed
    if _tg_hook_installed: return
    try:
        LaunchActivity = find_class("org.telegram.ui.LaunchActivity")
        IntentClass = find_class("android.content.Intent")
        LAClass = LaunchActivity.getClass() if hasattr(LaunchActivity, "getClass") else LaunchActivity
        hooked = False
        for method in LAClass.getDeclaredMethods():
            if method.getName() == "handleIntent":
                params = method.getParameterTypes()
                if params and len(params) > 0 and (params[0] == IntentClass or params[0].getName() == "android.content.Intent"):
                    plugin_self.hook_method(method, _TGIntentHook())
                    hooked = True
        if hooked: _tg_hook_installed = True; log("[MandreLib] Хук для tg:// алиасов успешно установлен.")
        else: _tg_hook_installed = True; log("[MandreLib] Не удалось найти подходящий метод handleIntent для хука.")
    except Exception: log(f"[MandreLib] Не удалось установить хук для tg:// алиасов: {traceback.format_exc()}")

def _scheduler_tick():
    global _SCHEDULER_RUNNABLE
    with _TASK_LOCK:
        tasks_snapshot = list(_TASKS.items())
    now = time.time()
    for key, info in tasks_snapshot:
        if now >= info["next_ts"] and key not in _RUNNING_TASKS:
            _RUNNING_TASKS.add(key)
            
            def task_wrapper(k=key, cb=info["cb"]):
                try:
                    cb()
                except Exception:
                    log(f"[MandreLib] Ошибка в задаче '{k}': {traceback.format_exc()}")
                finally:
                    with _TASK_LOCK:
                        _RUNNING_TASKS.discard(k)
            
            run_on_queue(task_wrapper)
            
            with _TASK_LOCK:
                if key in _TASKS:
                    _TASKS[key]["next_ts"] = now + _TASKS[key]["interval"]
    
    with _TASK_LOCK:
        if _TASKS:
            _SCHEDULER_HANDLER.postDelayed(_SCHEDULER_RUNNABLE, 1000)
        else:
            _SCHEDULER_RUNNABLE = None
            log("[MandreLib] Планировщик остановлен, задач нет.")

class _SchedulerRunnable(dynamic_proxy(Runnable)):
    def run(self):
        try:
            _scheduler_tick()
        except Exception as e:
            log(f"[MandreLib] Критическая ошибка в планировщике: {e}")

class MandreData:
    @staticmethod
    def _get_base_data_dir() -> File:
        base_dir = File(ApplicationLoader.getFilesDirFixed(), "plugins")
        data_dir = File(base_dir, "mandre_lib_data")
        if not data_dir.exists(): data_dir.mkdirs()
        return data_dir

    @staticmethod
    def get_persistent_path(plugin_id: str, filename: str) -> str:
        plugin_dir = File(MandreData._get_base_data_dir(), plugin_id)
        if not plugin_dir.exists(): plugin_dir.mkdirs()
        return File(plugin_dir, filename).getAbsolutePath()

    @staticmethod
    def write_persistent_json(plugin_id: str, filename: str, data: Any):
        path = MandreData.get_persistent_path(plugin_id, filename)
        with _DATA_LOCK:
            try:
                with open(path, 'w', encoding='utf-8') as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)
            except Exception as e: log(f"[MandreData] Ошибка записи в {path}: {e}")

    @staticmethod
    def read_persistent_json(plugin_id: str, filename: str, default: Any = None) -> Any:
        path = MandreData.get_persistent_path(plugin_id, filename)
        with _DATA_LOCK:
            if not os.path.exists(path): return default
            try:
                with open(path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except (json.JSONDecodeError, IOError) as e:
                log(f"[MandreData] Ошибка чтения {path}: {e}")
                return default
    
    @staticmethod
    def list_persistent_plugins() -> List[str]:
        plugins = []
        base_dir = MandreData._get_base_data_dir()
        if not base_dir.exists(): return []
        for plugin_id_dir in base_dir.listFiles():
            if plugin_id_dir.isDirectory():
                if "_validation_test_" not in plugin_id_dir.getName():
                    plugins.append(plugin_id_dir.getName())
        return plugins
    
    @staticmethod
    def list_files_for_plugin(plugin_id: str) -> List[str]:
        files = []
        plugin_dir = File(MandreData._get_base_data_dir(), plugin_id)
        if plugin_dir.isDirectory():
            for data_file in plugin_dir.listFiles():
                if data_file.isFile():
                    files.append(data_file.getName())
        return files

    @staticmethod
    def delete_persistent_plugin_data(plugin_id: str) -> bool:
        plugin_dir = File(MandreData._get_base_data_dir(), plugin_id)
        with _DATA_LOCK:
            try:
                if plugin_dir.exists() and plugin_dir.isDirectory():
                    for f in plugin_dir.listFiles():
                        f.delete()
                    plugin_dir.delete()
                    log(f"[MandreData] Все данные для плагина {plugin_id} удалены.")
                    return True
            except Exception as e:
                log(f"[MandreData] Не удалось удалить данные для {plugin_id}: {e}")
        return False

class _BottomBarHooks:
    class ViewCreatedHook(MethodHook):
        def after_hooked_method(self, param):
            try:
                fragment = param.thisObject
                if not isinstance(fragment, PluginSettingsActivity): return
                
                java_plugin_obj = get_private_field(fragment, "plugin")
                if not java_plugin_obj or not hasattr(java_plugin_obj, "getId"): return
                
                plugin_id = java_plugin_obj.getId()
                if plugin_id not in _BOTTOM_BAR_CONFIGS: return
                
                config = _BOTTOM_BAR_CONFIGS[plugin_id]
                
                python_plugin_instance = config.get("plugin_instance")
                if not python_plugin_instance:
                    log(f"[MandreLib] Не удалось найти Python-экземпляр для {plugin_id}")
                    return

                active_index = python_plugin_instance.get_setting(config["active_index_key"], 0)
                config["active_index"] = active_index

                root_view = get_private_field(fragment, "fragmentView")
                if not root_view or not isinstance(root_view, FrameLayout):
                    log("[MandreLib] Не удалось получить root_view (fragmentView) для BottomBar.")
                    return

                list_view = get_private_field(fragment, "listView")
                if list_view and isinstance(list_view, RecyclerListView):
                    list_view.setPadding(0, 0, 0, AndroidUtilities.dp(80))

                MandreUI._create_and_add_bar(activity=fragment.getParentActivity(), root_view=root_view, config=config)
            except Exception:
                log(f"[MandreLib] Ошибка в хуке ViewCreated: {traceback.format_exc()}")
                
    class ViewDestroyedHook(MethodHook):
        def before_hooked_method(self, param):
            try:
                fragment = param.thisObject
                if not isinstance(fragment, PluginSettingsActivity): return
                
                plugin = get_private_field(fragment, "plugin")
                if plugin and hasattr(plugin, "getId") and plugin.getId() in _BOTTOM_BAR_CONFIGS:
                    plugin_id = plugin.getId()
                    bar = _BOTTOM_BAR_CONFIGS[plugin_id].get("view_instance")
                    if bar and bar.getParent():
                        bar.getParent().removeView(bar)
                        _BOTTOM_BAR_CONFIGS[plugin_id]["view_instance"] = None
                        _BOTTOM_BAR_CONFIGS[plugin_id]["ui_elements"] = []
                        log(f"[MandreLib] BottomBar для плагина {plugin_id} удален при уничтожении View.")
            except Exception:
                log(f"[MandreLib] Ошибка в хуке ViewDestroyed: {traceback.format_exc()}")

# --- Новые внутренние функции для TTS ---
def _internal_ensure_tts():
    ctx = ApplicationLoader.applicationContext
    if not ctx: return False
    if _TTS_STATE.tts and _TTS_STATE.init_ok: return True
    if _TTS_STATE.deferred: return False
    _TTS_STATE.deferred = True

    def init_on_ui():
        try:
            class _OnInit(dynamic_proxy(TextToSpeech.OnInitListener)):
                def onInit(self, status):
                    _TTS_STATE.init_ok = (status == TextToSpeech.SUCCESS)
                    if _TTS_STATE.init_ok:
                        try: _TTS_STATE.tts.setLanguage(Locale.getDefault())
                        except: pass
                    else: log(f"[MandreLib TTS] init failed: status={status}")

            listener = _OnInit()
            try: _TTS_STATE.tts = TextToSpeech(ctx, listener, GOOGLE_TTS_PKG); _TTS_STATE.engine = GOOGLE_TTS_PKG
            except: _TTS_STATE.tts = TextToSpeech(ctx, listener); _TTS_STATE.engine = None
        except Exception as e: log(f"[MandreLib TTS] init error: {e}")
        finally: _TTS_STATE.deferred = False
    
    run_on_ui_thread(init_on_ui)
    return False

def _internal_shutdown_tts():
    try:
        if _TTS_STATE.tts:
            try: _TTS_STATE.tts.stop()
            except: pass
            try: _TTS_STATE.tts.shutdown()
            except: pass
            _TTS_STATE.tts = None
            _TTS_STATE.init_ok = False
            log("[MandreLib TTS] движок остановлен.")
    except Exception as e: log(f"[MandreLib TTS] shutdown error: {e}")
# -----------------------------------

class MandreTTS:
    @staticmethod
    def speak(text: str):
        """Озвучивает текст, используя системный TTS."""
        try:
            if not text or TextUtils.isEmpty(text): return
            if not (_TTS_STATE.tts and _TTS_STATE.init_ok):
                if not _internal_ensure_tts():
                    log("[MandreLib TTS] Инициализация... Попробуйте через секунду.")
                    BulletinHelper.show_info("Инициализация синтезатора...")
                    return

            def speak_on_ui():
                try: _TTS_STATE.tts.speak(text, TextToSpeech.QUEUE_FLUSH, None, "mandre_tts")
                except: _TTS_STATE.tts.speak(text, TextToSpeech.QUEUE_FLUSH, None)
            
            run_on_ui_thread(speak_on_ui)
        except Exception as e: log(f"[MandreLib TTS] speak error: {e}")

class _AuthActivityResultHook(MethodHook):
    def before_hooked_method(self, param):
        global _auth_hook, _auth_success_cb, _auth_failure_cb
        try:
            request_code, result_code = param.args[0], param.args[1]
            if request_code == _AUTH_REQUEST_CODE:
                param.setResult(None) # Предотвращаем дальнейшую обработку
                if result_code == Activity.RESULT_OK:
                    if callable(_auth_success_cb): run_on_ui_thread(_auth_success_cb)
                else:
                    if callable(_auth_failure_cb): run_on_ui_thread(_auth_failure_cb)
        except Exception: log(f"[MandreLib Auth] Ошибка в хуке результата: {traceback.format_exc()}")
        finally:
            if _auth_hook: _mandrelib_instance.unhook_method(_auth_hook); _auth_hook = None
            _auth_success_cb = None; _auth_failure_cb = None

class MandreAuth:
    @staticmethod
    def request(on_success: Callable, on_failure: Callable, title: str = "Подтверждение личности", description: str = "Это необходимо для доступа."):
        """Запрашивает аутентификацию через экран блокировки устройства."""
        global _auth_hook, _auth_success_cb, _auth_failure_cb
        
        def runner():
            global _auth_hook, _auth_success_cb, _auth_failure_cb
            try:
                fragment = get_last_fragment()
                activity = fragment.getParentActivity() if fragment else None
                if not activity:
                    BulletinHelper.show_error("Не удалось получить доступ к текущему экрану."); run_on_ui_thread(on_failure); return

                keyguard = activity.getSystemService("keyguard")
                if not keyguard or not keyguard.isKeyguardSecure():
                    BulletinHelper.show_info("Экран блокировки не настроен. Доступ разрешен."); run_on_ui_thread(on_success); return

                _auth_success_cb, _auth_failure_cb = on_success, on_failure
                intent = keyguard.createConfirmDeviceCredentialIntent(title, description)
                if not intent:
                    BulletinHelper.show_error("Не удалось создать запрос аутентификации."); run_on_ui_thread(on_failure); return

                if _auth_hook: _mandrelib_instance.unhook_method(_auth_hook)
                
                method = activity.getClass().getDeclaredMethod("onActivityResult", JInteger.TYPE, JInteger.TYPE, Intent)
                _auth_hook = _mandrelib_instance.hook_method(method, _AuthActivityResultHook())
                
                activity.startActivityForResult(intent, _AUTH_REQUEST_CODE)
            except Exception:
                log(f"[MandreLib Auth] Ошибка при вызове экрана блокировки: {traceback.format_exc()}")
                BulletinHelper.show_error("Ошибка аутентификации."); run_on_ui_thread(on_failure)
        
        run_on_ui_thread(runner)

class MandreDevice:
    @staticmethod
    def get_device_info() -> Dict[str, Any]:
        """Получает подробную информацию об устройстве."""
        try:
            context = ApplicationLoader.applicationContext
            if not context:
                return {"error": "Не удалось получить контекст приложения"}
            
            device_info = {}
            
            # Базовая информация об устройстве
            device_info["manufacturer"] = Build.MANUFACTURER or "Unknown"
            device_info["model"] = Build.MODEL or "Unknown"
            device_info["brand"] = Build.BRAND or "Unknown"
            device_info["product"] = Build.PRODUCT or "Unknown"
            device_info["device"] = Build.DEVICE or "Unknown"
            device_info["board"] = Build.BOARD or "Unknown"
            device_info["hardware"] = Build.HARDWARE or "Unknown"
            
            # Информация об Android
            device_info["android_version"] = Build.VERSION.RELEASE or "Unknown"
            device_info["api_level"] = Build.VERSION.SDK_INT
            device_info["codename"] = Build.VERSION.CODENAME or "Unknown"
            device_info["incremental"] = Build.VERSION.INCREMENTAL or "Unknown"
            
            # Информация о сборке
            device_info["build_id"] = Build.ID or "Unknown"
            device_info["build_type"] = Build.TYPE or "Unknown"
            device_info["build_tags"] = Build.TAGS or "Unknown"
            device_info["build_time"] = Build.TIME
            device_info["build_user"] = Build.USER or "Unknown"
            device_info["build_host"] = Build.HOST or "Unknown"
            device_info["build_fingerprint"] = Build.FINGERPRINT or "Unknown"
            
            # Информация о дисплее
            try:
                from android.util import DisplayMetrics
                from android.view import WindowManager
                
                wm = context.getSystemService("window")
                if wm:
                    display = wm.getDefaultDisplay()
                    if display:
                        metrics = DisplayMetrics()
                        display.getMetrics(metrics)
                        
                        device_info["screen_width"] = metrics.widthPixels
                        device_info["screen_height"] = metrics.heightPixels
                        device_info["screen_density"] = metrics.density
                        device_info["screen_density_dpi"] = metrics.densityDpi
                        device_info["screen_xdpi"] = metrics.xdpi
                        device_info["screen_ydpi"] = metrics.ydpi
            except Exception as e:
                device_info["screen_error"] = str(e)
            
            # Информация о памяти
            try:
                from android.app import ActivityManager
                
                am = context.getSystemService("activity")
                if am:
                    memory_info = am.getMemoryInfo()
                    if memory_info:
                        device_info["total_memory_mb"] = memory_info.totalMem // (1024 * 1024)
                        device_info["available_memory_mb"] = memory_info.availMem // (1024 * 1024)
            except Exception as e:
                device_info["memory_error"] = str(e)
            
            # Информация о процессоре
            device_info["cpu_abi"] = Build.CPU_ABI or "Unknown"
            device_info["cpu_abi2"] = Build.CPU_ABI2 or "Unknown"
            device_info["supported_abis"] = list(Build.SUPPORTED_ABIS) if hasattr(Build, 'SUPPORTED_ABIS') else []
            
            # Информация о телефоне (если доступно)
            try:
                tm = context.getSystemService("phone")
                if tm:
                    device_info["phone_type"] = tm.getPhoneType()
                    device_info["network_operator"] = tm.getNetworkOperator() or "Unknown"
                    device_info["network_operator_name"] = tm.getNetworkOperatorName() or "Unknown"
                    device_info["sim_operator"] = tm.getSimOperator() or "Unknown"
                    device_info["sim_operator_name"] = tm.getSimOperatorName() or "Unknown"
                    device_info["sim_country_iso"] = tm.getSimCountryIso() or "Unknown"
                    device_info["sim_serial"] = tm.getSimSerialNumber() or "Unknown"
                    device_info["subscriber_id"] = tm.getSubscriberId() or "Unknown"
            except Exception as e:
                device_info["phone_error"] = str(e)
            
            # Информация о приложении
            try:
                package_info = context.getPackageManager().getPackageInfo(context.getPackageName(), 0)
                device_info["app_version_name"] = package_info.versionName or "Unknown"
                device_info["app_version_code"] = package_info.versionCode
                device_info["app_package"] = context.getPackageName()
            except Exception as e:
                device_info["app_error"] = str(e)
            
            # Дополнительная информация
            device_info["is_emulator"] = MandreDevice._is_emulator()
            device_info["is_rooted"] = MandreDevice._is_rooted()
            device_info["locale"] = str(Locale.getDefault())
            device_info["timezone"] = str(TimeZone.getDefault().getID())
            
            # Время получения информации
            device_info["timestamp"] = int(time.time())
            device_info["timestamp_formatted"] = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
            
            return device_info
            
        except Exception as e:
            log(f"[MandreLib Device] Ошибка получения информации об устройстве: {e}")
            return {"error": str(e)}
    
    @staticmethod
    def _is_emulator() -> bool:
        """Проверяет, запущено ли приложение в эмуляторе."""
        try:
            return (Build.FINGERPRINT and "generic" in Build.FINGERPRINT) or \
                   (Build.MODEL and "google_sdk" in Build.MODEL) or \
                   (Build.MODEL and "Android SDK built for x86" in Build.MODEL) or \
                   (Build.MANUFACTURER and "Genymotion" in Build.MANUFACTURER) or \
                   (Build.HARDWARE and "goldfish" in Build.HARDWARE) or \
                   (Build.PRODUCT and "sdk" in Build.PRODUCT) or \
                   (Build.PRODUCT and "google_sdk" in Build.PRODUCT)
        except:
            return False
    
    @staticmethod
    def _is_rooted() -> bool:
        """Проверяет, есть ли root права на устройстве."""
        try:
            # Проверяем наличие su
            su_paths = ["/system/bin/su", "/system/xbin/su", "/sbin/su", "/system/su", "/system/bin/.ext/.su"]
            for path in su_paths:
                if os.path.exists(path):
                    return True
            
            # Проверяем наличие busybox
            if os.path.exists("/system/bin/busybox") or os.path.exists("/system/xbin/busybox"):
                return True
                
            return False
        except:
            return False
    
    @staticmethod
    def get_simple_info() -> str:
        """Возвращает краткую информацию об устройстве в виде строки."""
        try:
            info = MandreDevice.get_device_info()
            if "error" in info:
                return f"Ошибка: {info['error']}"
            
            return f"{info.get('manufacturer', 'Unknown')} {info.get('model', 'Unknown')} (Android {info.get('android_version', 'Unknown')}, API {info.get('api_level', 'Unknown')})"
        except Exception as e:
            return f"Ошибка получения информации: {e}"

class MandreNotification:
    @staticmethod
    def show_simple(title: str, text: str, channel_id: str = "mandrelib_notifications"):
        """Показывает простое уведомление."""
        try:
            context = ApplicationLoader.applicationContext
            if not context:
                return
            
            # Создаем канал для Android 8.0+
            if Build.VERSION.SDK_INT >= 26:
                notification_manager = context.getSystemService(Context.NOTIFICATION_SERVICE)
                if notification_manager.getNotificationChannel(channel_id) is None:
                    channel = NotificationChannel(channel_id, "MandreLib Notifications", NotificationManager.IMPORTANCE_DEFAULT)
                    notification_manager.createNotificationChannel(channel)
            
            # Создаем уведомление
            builder = NotificationCompat.Builder(context, channel_id)
            builder.setSmallIcon(R.drawable.msg_notifications_solar)
            builder.setContentTitle(title)
            builder.setContentText(text)
            builder.setColor(Theme.getColor(Theme.key_actionBarDefault))
            builder.setAutoCancel(True)
            builder.setPriority(0) # NotificationCompat.PRIORITY_DEFAULT
            builder.setDefaults(-1) # NotificationCompat.DEFAULT_ALL
            
            # Показываем уведомление
            notification_manager_compat = NotificationManagerCompat.from_(context)
            notification_id = int(time.time()) % 10000
            notification_manager_compat.notify(notification_id, builder.build())
            
            log(f"[MandreLib Notification] Показано простое уведомление: {title}")
            
        except Exception as e:
            log(f"[MandreLib Notification] Ошибка показа простого уведомления: {e}")
    
    @staticmethod
    def show_dialog(sender_name: str, message: str, avatar_url: str = None, channel_id: str = "mandrelib_dialog_notifications"):
        """Показывает уведомление в стиле диалога с аватаром."""
        try:
            context = ApplicationLoader.applicationContext
            if not context:
                return
            
            # Создаем канал для Android 8.0+
            if Build.VERSION.SDK_INT >= 26:
                notification_manager = context.getSystemService(Context.NOTIFICATION_SERVICE)
                if notification_manager.getNotificationChannel(channel_id) is None:
                    channel = NotificationChannel(channel_id, "MandreLib Dialog Notifications", NotificationManager.IMPORTANCE_DEFAULT)
                    notification_manager.createNotificationChannel(channel)
            
            # Загружаем и обрабатываем аватар
            avatar_bitmap = None
            if avatar_url:
                try:
                    import requests
                    response = requests.get(avatar_url, timeout=5)
                    if response.status_code == 200:
                        image_bytes = response.content
                        decoded_bitmap = BitmapFactory.decodeByteArray(image_bytes, 0, len(image_bytes))
                        avatar_bitmap = MandreNotification._get_circular_bitmap(decoded_bitmap)
                except:
                    pass
            
            # Создаем Person для отправителя
            sender_builder = Person.Builder().setName(sender_name)
            if avatar_bitmap:
                icon = IconCompat.createWithBitmap(avatar_bitmap)
                sender_builder.setIcon(icon)
            sender = sender_builder.build()
            
            # Создаем Person для получателя
            user = Person.Builder().setName("You").build()
            
            # Создаем MessagingStyle
            messaging_style = NotificationCompat.MessagingStyle(user)
            messaging_style.setGroupConversation(False)
            
            timestamp = int(time.time() * 1000)
            msg = NotificationCompat.MessagingStyle.Message(message, timestamp, sender)
            messaging_style.addMessage(msg)
            
            # Создаем уведомление
            builder = NotificationCompat.Builder(context, channel_id)
            builder.setStyle(messaging_style)
            builder.setSmallIcon(R.drawable.msg_notifications_solar)
            builder.setColor(Theme.getColor(Theme.key_actionBarDefault))
            builder.setAutoCancel(True)
            builder.setPriority(0) # NotificationCompat.PRIORITY_DEFAULT
            builder.setDefaults(-1) # NotificationCompat.DEFAULT_ALL
            
            # Показываем уведомление
            notification_manager_compat = NotificationManagerCompat.from_(context)
            notification_id = int(time.time()) % 10000
            notification_manager_compat.notify(notification_id, builder.build())
            
            log(f"[MandreLib Notification] Показано диалог уведомление от {sender_name}")
            
        except Exception as e:
            log(f"[MandreLib Notification] Ошибка показа диалог уведомления: {e}")
    
    @staticmethod
    def _get_circular_bitmap(bitmap):
        """Обрезает Bitmap в круг."""
        if bitmap is None:
            return None
        
        width = bitmap.getWidth()
        height = bitmap.getHeight()
        
        output = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
        canvas = Canvas(output)
        
        paint = Paint()
        rect = Rect(0, 0, width, height)
        rect_f = RectF(rect)
        
        paint.setAntiAlias(True)
        canvas.drawARGB(0, 0, 0, 0)
        paint.setARGB(255, 255, 255, 255)
        canvas.drawOval(rect_f, paint)
        
        paint.setXfermode(PorterDuffXfermode(PorterDuff.Mode.SRC_IN))
        canvas.drawBitmap(bitmap, rect, rect, paint)
        
        return output

class MandreShare:
    @staticmethod
    def share_text(text: str, title: str = "Поделиться"):
        """Открывает системный диалог 'Поделиться' с текстом."""
        try:
            if not text or not text.strip():
                BulletinHelper.show_error("Текст для отправки пуст.")
                return
                
            def share_runner():
                try:
                    fragment = get_last_fragment()
                    if not fragment:
                        BulletinHelper.show_error("Не удалось получить доступ к текущему экрану.")
                        return
                        
                    context = fragment.getParentActivity()
                    if not context:
                        BulletinHelper.show_error("Не удалось получить контекст приложения.")
                        return
                    
                    intent = Intent(Intent.ACTION_SEND)
                    intent.setType("text/plain")
                    intent.putExtra(Intent.EXTRA_TEXT, text)
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    
                    chooser = Intent.createChooser(intent, title)
                    chooser.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    
                    context.startActivity(chooser)
                    log(f"[MandreLib Share] Открыт диалог 'Поделиться' с текстом: {text[:50]}...")
                    
                except Exception as e:
                    log(f"[MandreLib Share] Ошибка при открытии диалога 'Поделиться': {e}")
                    BulletinHelper.show_error(f"Ошибка при открытии диалога: {str(e)}")
            
            run_on_ui_thread(share_runner)
            
        except Exception as e:
            log(f"[MandreLib Share] Критическая ошибка: {e}")
            BulletinHelper.show_error("Критическая ошибка при открытии диалога 'Поделиться'.")
    
    @staticmethod
    def share_file(file_path: str, title: str = "Поделиться файлом", mime_type: str = None):
        """Открывает системный диалог 'Поделиться' с файлом."""
        try:
            if not file_path or not file_path.strip():
                BulletinHelper.show_error("Путь к файлу не указан.")
                return
                
            if not os.path.exists(file_path):
                BulletinHelper.show_error("Файл не найден.")
                return
                
            if not os.path.isfile(file_path):
                BulletinHelper.show_error("Указанный путь не является файлом.")
                return
                
            def share_runner():
                try:
                    fragment = get_last_fragment()
                    if not fragment:
                        BulletinHelper.show_error("Не удалось получить доступ к текущему экрану.")
                        return
                        
                    context = fragment.getParentActivity()
                    if not context:
                        BulletinHelper.show_error("Не удалось получить контекст приложения.")
                        return
                    
                    # Определяем MIME-тип если не указан
                    current_mime_type = mime_type
                    if not current_mime_type:
                        current_mime_type = MandreShare._get_file_mime_type(file_path)
                    
                    # Копируем файл в Downloads/exteraGram
                    import shutil
                    from android.os import Environment
                    
                    source_file = File(file_path)
                    filename = source_file.getName()
                    
                    download_dir = Environment.getExternalStoragePublicDirectory(
                        Environment.DIRECTORY_DOWNLOADS
                    )
                    exteragram_dir = File(download_dir, "exteraGram")
                    
                    if not exteragram_dir.exists():
                        exteragram_dir.mkdirs()
                    
                    dest_file = File(exteragram_dir, filename)
                    
                    # Копируем файл
                    shutil.copy2(file_path, dest_file.getAbsolutePath())
                    log(f"[MandreLib Share] Файл скопирован в: {dest_file.getAbsolutePath()}")
                    
                    # Создаем URI для файла
                    authority = ApplicationLoader.getApplicationId() + ".provider"
                    uri = FileProvider.getUriForFile(context, authority, dest_file)
                    
                    # Создаем Intent для отправки файла
                    intent = Intent(Intent.ACTION_SEND)
                    intent.setType(current_mime_type)
                    intent.putExtra(Intent.EXTRA_STREAM, uri)
                    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                    
                    chooser = Intent.createChooser(intent, title)
                    context.startActivity(chooser)
                    
                    success_msg = f"Файл готов к отправке: {filename}"
                    BulletinHelper.show_success(success_msg)
                    log(f"[MandreLib Share] Открыт диалог 'Поделиться' с файлом: {filename}")
                    
                    # Очищаем временный файл через 5 минут
                    threading.Thread(
                        target=lambda: MandreShare._cleanup_temp_file(dest_file.getAbsolutePath(), 300),
                        daemon=True
                    ).start()
                    
                except Exception as e:
                    log(f"[MandreLib Share] Ошибка при открытии диалога 'Поделиться' с файлом: {e}")
                    BulletinHelper.show_error(f"Ошибка при открытии диалога: {str(e)}")
            
            run_on_ui_thread(share_runner)
            
        except Exception as e:
            log(f"[MandreLib Share] Критическая ошибка при отправке файла: {e}")
            BulletinHelper.show_error("Критическая ошибка при отправке файла.")
    
    @staticmethod
    def _get_file_mime_type(file_path: str) -> str:
        """Определяет MIME-тип файла по его расширению."""
        try:
            ext = file_path.lower().split('.')[-1] if '.' in file_path else ''
            mime_types = {
                # Изображения
                'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'png': 'image/png', 
                'gif': 'image/gif', 'webp': 'image/webp', 'bmp': 'image/bmp',
                'svg': 'image/svg+xml', 'ico': 'image/x-icon',
                
                # Видео
                'mp4': 'video/mp4', 'webm': 'video/webm', 'mov': 'video/quicktime',
                'avi': 'video/x-msvideo', 'mkv': 'video/x-matroska',
                
                # Аудио
                'mp3': 'audio/mpeg', 'wav': 'audio/wav', 'ogg': 'audio/ogg',
                'm4a': 'audio/mp4', 'aac': 'audio/aac', 'flac': 'audio/flac',
                
                # Документы
                'pdf': 'application/pdf', 'doc': 'application/msword',
                'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                'xls': 'application/vnd.ms-excel',
                'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                'ppt': 'application/vnd.ms-powerpoint',
                'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
                'txt': 'text/plain', 'rtf': 'application/rtf',
                
                # Архивы
                'zip': 'application/zip', 'rar': 'application/x-rar-compressed',
                '7z': 'application/x-7z-compressed', 'tar': 'application/x-tar',
                'gz': 'application/gzip',
                
                # JSON/XML
                'json': 'application/json', 'xml': 'application/xml',
                'html': 'text/html', 'css': 'text/css', 'js': 'application/javascript',
                
                # Telegram специфичные
                'tgs': 'application/x-tgsticker'
            }
            return mime_types.get(ext, 'application/octet-stream')
        except Exception:
            return 'application/octet-stream'
    
    @staticmethod
    def _cleanup_temp_file(file_path: str, delay_seconds: int):
        """Удаляет временный файл через указанное время."""
        try:
            time.sleep(delay_seconds)
            if os.path.exists(file_path):
                os.remove(file_path)
                log(f"[MandreLib Share] Временный файл удален: {file_path}")
        except Exception as e:
            log(f"[MandreLib Share] Ошибка удаления временного файла: {e}")

class MandreUI:
    @staticmethod
    def _internal_invoke_ripple(x: float, y: float, intensity: float):
        global _make_ripple_method
        try:
            if not _make_ripple_method:
                LaunchActivity = find_class("org.telegram.ui.LaunchActivity")
                LAClass = LaunchActivity.getClass() if hasattr(LaunchActivity, "getClass") else LaunchActivity
                _make_ripple_method = LAClass.getDeclaredMethod("makeRipple", JFloat.TYPE, JFloat.TYPE, JFloat.TYPE)
                _make_ripple_method.setAccessible(True)
            if _make_ripple_method:
                _make_ripple_method.invoke(None, JFloat(x), JFloat(y), JFloat(intensity))
        except Exception as e: log(f"[MandreLib] Ошибка вызова ripple: {e}")

    @staticmethod
    def _internal_perform_vibration(context: Any, intensity: float):
        try:
            vibrator = context.getSystemService("vibrator")
            if not vibrator: return
            amp = int(min(255, max(1, 255 * (intensity / 3.0))))
            duration = 20
            if Build.VERSION.SDK_INT >= 26: vibrator.vibrate(VibrationEffect.createOneShot(duration, amp))
            else: vibrator.vibrate(duration)
        except Exception as e: log(f"[MandreLib] Ошибка вибрации: {e}")

    @staticmethod
    def ripple(intensity: float = 2.0, vibrate: bool = True):
        def effect_runner():
            try:
                fragment = get_last_fragment()
                activity = fragment.getParentActivity() if fragment else None
                if not activity: return
                view = activity.getWindow().getDecorView()
                center_x, center_y = float(view.getWidth() / 2.0), float(view.getHeight() / 2.0)
                MandreUI._internal_invoke_ripple(center_x, center_y, intensity)
                if vibrate: MandreUI._internal_perform_vibration(activity, intensity)
            except Exception as e: log(f"[MandreLib] Ошибка при запуске эффекта ripple: {e}")
        run_on_ui_thread(effect_runner)

    @staticmethod
    def show(title: str, items: List[str], on_select: Callable[[int, str], None], message: Optional[str] = None, cancel_text: Optional[str] = "Отмена"):
        def dialog_runner():
            try:
                fragment = get_last_fragment()
                activity = fragment.getParentActivity() if fragment else None
                if not activity: BulletinHelper.show_error("Ошибка UI: не удалось получить контекст."); return
                builder = AlertDialogBuilder(activity)
                builder.set_title(title)
                if message: builder.set_message(message)
                def internal_on_select_proxy(dialog, index: int):
                    try:
                        if 0 <= index < len(items): on_select(index, items[index])
                    except Exception as e: log(f"[MandreLib] Ошибка в колбэке on_select: {e}")
                    finally: dialog.dismiss()
                builder.set_items(items, internal_on_select_proxy)
                if cancel_text: builder.set_negative_button(cancel_text, lambda d, w: d.dismiss())
                builder.show()
            except Exception as e: log(f"[MandreLib] Не удалось создать диалог: {e}")
        run_on_ui_thread(dialog_runner)

    @staticmethod
    def select_chat(title: str, on_select: Callable[[Dict[str, Any]], None], search_hint: str = "Поиск по названию или ID...", cancel_text: str = "Отмена"):
        INITIAL_LOAD_COUNT = 25; BATCH_LOAD_COUNT = 35; VIEW_POOL_SIZE = 30
        def dialog_starter():
            fragment = get_last_fragment()
            context = fragment.getParentActivity() if fragment else None
            if not context: BulletinHelper.show_error("Ошибка UI: не удалось получить контекст."); return
            spinner = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_SPINNER)
            spinner.set_message("Загрузка чатов...").show().set_cancelable(False)
            def _initial_load_task():
                try:
                    mc = get_messages_controller(); user_config = get_user_config(); dialogs_copy = ArrayList(mc.getDialogs(0))
                    def process_dialog(dialog):
                        dialog_id, chat_title, chat_obj = dialog.id, None, None
                        if dialog_id == user_config.getClientUserId(): chat_title, chat_obj = "Избранное", mc.getUser(dialog_id)
                        elif dialog_id > 0: user = mc.getUser(dialog_id); chat_title, chat_obj = ((f"{user.first_name or ''} {user.last_name or ''}".strip(), user) if user else (None, None))
                        elif dialog_id < 0: chat = mc.getChat(-dialog_id); chat_title, chat_obj = ((chat.title, chat) if chat else (None, None))
                        return {"title": chat_title.strip(), "id": dialog_id, "obj": chat_obj} if chat_title else None
                    run_on_ui_thread(lambda: _display_dialog_on_ui(dialogs_copy, process_dialog))
                except Exception: log(f"[MandreLib] Ошибка загрузки чатов: {traceback.format_exc()}"); run_on_ui_thread(lambda: (spinner.dismiss(), BulletinHelper.show_error("Не удалось загрузить чаты.")))
            def _display_dialog_on_ui(dialogs_copy, process_dialog_func):
                all_chats_python = []; root_layout = LinearLayout(context); root_layout.setOrientation(LinearLayout.VERTICAL)
                search_field = EditText(context); search_field.setHint(search_hint); search_field.setSingleLine(True); search_field.setTextColor(Theme.getColor(Theme.key_dialogTextBlack)); search_field.setHintTextColor(Theme.getColor(Theme.key_dialogTextHint)); search_field.setBackground(None); search_field.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(10), AndroidUtilities.dp(16), AndroidUtilities.dp(10)); root_layout.addView(search_field)
                scroll_view = ScrollView(context); root_layout.addView(scroll_view, LinearLayout.LayoutParams(-1, -1, 1.0)); chat_list_layout = LinearLayout(context); chat_list_layout.setOrientation(LinearLayout.VERTICAL); scroll_view.addView(chat_list_layout)
                loading_indicator = TextView(context); loading_indicator.setText("Загрузка..."); loading_indicator.setPadding(0, AndroidUtilities.dp(10), 0, AndroidUtilities.dp(10)); loading_indicator.setGravity(Gravity.CENTER)
                builder = AlertDialogBuilder(context); builder.set_title(title)
                view_pool = []
                for _ in range(VIEW_POOL_SIZE):
                    row = LinearLayout(context); row.setOrientation(LinearLayout.HORIZONTAL); row.setGravity(Gravity.CENTER_VERTICAL); row.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(8), AndroidUtilities.dp(16), AndroidUtilities.dp(8)); row.setBackground(Theme.createSelectorDrawable(Theme.getColor(Theme.key_dialogButtonSelector), 2))
                    avatar = BackupImageView(context); avatar.setRoundRadius(AndroidUtilities.dp(20)); name = TextView(context); name.setTextSize(16); name.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                    row.addView(avatar, LinearLayout.LayoutParams(AndroidUtilities.dp(40), AndroidUtilities.dp(40))); params = LinearLayout.LayoutParams(-2, -2); params.leftMargin = AndroidUtilities.dp(16); row.addView(name, params)
                    row.setVisibility(View.GONE); chat_list_layout.addView(row); view_pool.append({"row": row, "avatar": avatar, "name": name, "click_listener": None})
                def internal_on_select_proxy(db, chat_info):
                    try: on_select(chat_info)
                    except Exception as e: log(f"[MandreLib] Ошибка в колбэке on_select: {e}")
                    finally: db.dismiss()
                def update_visible_list(chats_to_show, show_loading):
                    for i in range(VIEW_POOL_SIZE):
                        pool_item, row = view_pool[i], view_pool[i]["row"]
                        if i < len(chats_to_show):
                            chat_info = chats_to_show[i]; pool_item["name"].setText(chat_info["title"])
                            if chat_info["obj"]: pool_item["avatar"].setForUserOrChat(chat_info["obj"], AvatarDrawable(chat_info["obj"]))
                            else: pool_item["avatar"].clearImage()
                            click_listener = OnClickListener(lambda _, info=chat_info: internal_on_select_proxy(builder, info)); row.setOnClickListener(click_listener); pool_item["click_listener"] = click_listener; row.setVisibility(View.VISIBLE)
                        else: row.setVisibility(View.GONE)
                    if loading_indicator.getParent(): chat_list_layout.removeView(loading_indicator)
                    if show_loading: chat_list_layout.addView(loading_indicator)
                def batch_loader(offset):
                    if offset >= dialogs_copy.size(): run_on_ui_thread(lambda: update_visible_list(all_chats_python, False)); return
                    new_batch = [process_dialog_func(dialogs_copy.get(i)) for i in range(offset, min(offset + BATCH_LOAD_COUNT, dialogs_copy.size())) if process_dialog_func(dialogs_copy.get(i))]
                    all_chats_python.extend(new_batch)
                    if not search_field.getText().toString(): run_on_ui_thread(lambda: update_visible_list(all_chats_python, True))
                    run_on_queue(lambda: batch_loader(offset + BATCH_LOAD_COUNT))
                handler, sr, sg = Handler(Looper.getMainLooper()), [None], [0]
                def perform_filter_task(q, g):
                    filtered = all_chats_python if not q else [c for c in all_chats_python if q.lower() in c['title'].lower() or q in str(c['id'])]
                    if g == sg[0]: run_on_ui_thread(lambda: update_visible_list(filtered[:VIEW_POOL_SIZE], False))
                class SearchWatcher(dynamic_proxy(TextWatcher)):
                    def afterTextChanged(self, s):
                        if sr[0]: handler.removeCallbacks(sr[0])
                        sg[0] += 1; q, g = s.toString(), sg[0]
                        class DebouncedRunnable(dynamic_proxy(Runnable)):
                            def run(self): run_on_queue(lambda: perform_filter_task(q, g))
                        sr[0] = DebouncedRunnable(); handler.postDelayed(sr[0], 250)
                    def beforeTextChanged(self, s, st, c, a): pass
                    def onTextChanged(self, s, st, b, c): pass
                search_field.addTextChangedListener(SearchWatcher()); builder.set_view(root_layout); builder.set_negative_button(cancel_text, lambda d, w: d.dismiss()); builder.show()
                spinner.dismiss()
                initial_batch = [process_dialog_func(dialogs_copy.get(i)) for i in range(min(INITIAL_LOAD_COUNT, dialogs_copy.size())) if process_dialog_func(dialogs_copy.get(i))]
                all_chats_python.extend(initial_batch); show_loading = dialogs_copy.size() > INITIAL_LOAD_COUNT
                update_visible_list(all_chats_python, show_loading)
                if show_loading: run_on_queue(lambda: batch_loader(INITIAL_LOAD_COUNT))
            run_on_queue(_initial_load_task)
        run_on_ui_thread(dialog_starter)
    
    @staticmethod
    def _create_and_add_bar(activity, root_view, config):
        bar_container = LinearLayout(activity)
        bar_container.setOrientation(LinearLayout.HORIZONTAL)
        bar_container.setGravity(Gravity.CENTER)
        bar_container.setElevation(0)

        bg_drawable = GradientDrawable()
        bg_drawable.setColor(config["bg_color"])
        bg_drawable.setCornerRadius(AndroidUtilities.dp(config["corner_radius_dp"]))
        bg_drawable.setStroke(AndroidUtilities.dp(config["stroke_width_dp"]), config["stroke_color"])
        bar_container.setBackground(bg_drawable)
        
        ui_elements = []
        for i, item in enumerate(config["items"]):
            item_frame = FrameLayout(activity)
            frame_params = LinearLayout.LayoutParams(0, -1, 1.0)
            item_frame.setLayoutParams(frame_params)

            pill_view = View(activity)
            pill_bg = GradientDrawable()
            pill_bg.setColor(config["active_bg_color"])
            pill_bg.setCornerRadius(AndroidUtilities.dp(config["corner_radius_dp"] - 8))
            pill_view.setBackground(pill_bg)
            pill_params = FrameLayout.LayoutParams(-1, -1)
            pill_params.setMargins(AndroidUtilities.dp(4), AndroidUtilities.dp(4), AndroidUtilities.dp(4), AndroidUtilities.dp(4))
            pill_view.setLayoutParams(pill_params)
            
            is_active = (i == config["active_index"])
            pill_view.setAlpha(1.0 if is_active else 0.0)
            if is_active:
                pill_view.setScaleX(0.8); pill_view.setScaleY(0.8)
                pill_view.animate().scaleX(1.0).scaleY(1.0).setDuration(250).setInterpolator(DecelerateInterpolator()).start()
            item_frame.addView(pill_view)

            button_container = LinearLayout(activity)
            button_container.setOrientation(LinearLayout.VERTICAL)
            button_container.setGravity(Gravity.CENTER)
            button_container.setLayoutParams(FrameLayout.LayoutParams(-1, -1))
            button_container.setPadding(0, AndroidUtilities.dp(6), 0, AndroidUtilities.dp(6))
            button_container.setBackground(ColorDrawable(Color.TRANSPARENT))
            button_container.setClickable(True)

            tint_color = config["active_color"] if is_active else config["inactive_color"]
            
            icon_view = ImageView(activity)
            res_id = ApplicationLoader.applicationContext.getResources().getIdentifier(item.get("icon"), "drawable", ApplicationLoader.applicationContext.getPackageName())
            if res_id != 0:
                icon_view.setImageResource(res_id)
                icon_view.setColorFilter(tint_color)
            icon_params = LinearLayout.LayoutParams(AndroidUtilities.dp(24), AndroidUtilities.dp(24))
            button_container.addView(icon_view, icon_params)

            text_view = TextView(activity)
            text_view.setText(item.get("text", ""))
            text_view.setTextColor(tint_color)
            text_view.setTextSize(11)
            text_view.setGravity(Gravity.CENTER)
            text_params = LinearLayout.LayoutParams(-2, -2)
            text_params.topMargin = AndroidUtilities.dp(2)
            button_container.addView(text_view, text_params)
            
            def create_click_handler(index, on_click_callback, plugin_instance):
                def handler(*args):
                    if callable(on_click_callback):
                        on_click_callback()
                    # Обновляем визуальное состояние панели немедленно
                    Mandre.UI.update_bottom_bar(plugin_instance.id, index)
                    # Затем перезагружаем настройки для отображения нужной вкладки
                    Mandre.apply_and_refresh_settings(plugin_instance)
                return handler

            on_click_callback = item.get("on_click")
            button_container.setOnClickListener(OnClickListener(create_click_handler(i, on_click_callback, config["plugin_instance"])))
            
            item_frame.addView(button_container)
            bar_container.addView(item_frame)
            ui_elements.append({"icon": icon_view, "text": text_view, "pill": pill_view})

        bar_params = FrameLayout.LayoutParams(-1, AndroidUtilities.dp(56))
        bar_params.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL
        bar_params.setMargins(AndroidUtilities.dp(24), 0, AndroidUtilities.dp(24), AndroidUtilities.dp(12))
        
        root_view.addView(bar_container, bar_params)
        
        bar_container.setTranslationY(AndroidUtilities.dp(100))
        ObjectAnimator.ofFloat(bar_container, "translationY", AndroidUtilities.dp(100), 0).setDuration(250).start()
        
        config["view_instance"] = bar_container
        config["ui_elements"] = ui_elements

    @staticmethod
    def update_bottom_bar(plugin_id: str, active_index: int):
        def updater():
            if plugin_id not in _BOTTOM_BAR_CONFIGS: return
            config = _BOTTOM_BAR_CONFIGS[plugin_id]
            
            if config.get("active_index") == active_index: return

            config["active_index"] = active_index
            
            ui_elements = config.get("ui_elements", [])
            for i, elements in enumerate(ui_elements):
                is_active = (i == active_index)
                tint_color = config["active_color"] if is_active else config["inactive_color"]
                
                elements["icon"].setColorFilter(tint_color)
                elements["text"].setTextColor(tint_color)
                
                pill = elements["pill"]
                target_alpha = 1.0 if is_active else 0.0
                if pill.getAlpha() != target_alpha:
                    pill.animate().alpha(target_alpha).setDuration(200).start()

        run_on_ui_thread(updater)

    @staticmethod
    def setup_settings_bottom_bar(
        plugin_instance: BasePlugin,
        items: List[Dict[str, Any]],
        active_index_key: str = "active_tab",
        bg_color: int = Color.argb(210, 50, 50, 55),
        active_color: int = Color.WHITE,
        inactive_color: int = Color.rgb(140, 140, 140),
        active_bg_color: int = Color.argb(80, 255, 255, 255),
        stroke_color: int = Color.argb(80, 120, 120, 120),
        stroke_width_dp: int = 1,
        corner_radius_dp: int = 28
    ):
        global _bottom_bar_hooks_installed
        plugin_id = plugin_instance.id

        _BOTTOM_BAR_CONFIGS[plugin_id] = {
            "plugin_id": plugin_id, "plugin_instance": plugin_instance,
            "items": items, "active_index_key": active_index_key,
            "bg_color": bg_color, "active_color": active_color, "inactive_color": inactive_color,
            "active_bg_color": active_bg_color, "stroke_color": stroke_color,
            "stroke_width_dp": stroke_width_dp, "corner_radius_dp": corner_radius_dp,
            "view_instance": None, "ui_elements": []
        }

        if _bottom_bar_hooks_installed:
            return

        try:
            ContextClass = find_class("android.content.Context")
            create_method = PluginSettingsActivity.getClass().getDeclaredMethod("createView", ContextClass)
            plugin_instance.hook_method(create_method, _BottomBarHooks.ViewCreatedHook())
            
            destroy_method = PluginSettingsActivity.getClass().getDeclaredMethod("onFragmentDestroy")
            plugin_instance.hook_method(destroy_method, _BottomBarHooks.ViewDestroyedHook())
            
            _bottom_bar_hooks_installed = True
            log("[MandreLib] Хуки для BottomBar успешно установлены.")
        except Exception:
            log(f"[MandreLib] Не удалось установить хуки для BottomBar: {traceback.format_exc()}")

class Mandre:
    UI = MandreUI
    Data = MandreData
    TTS = MandreTTS
    Auth = MandreAuth
    Share = MandreShare
    Device = MandreDevice
    Notification = MandreNotification
    Pip = MandrePip

    _DB_CACHE_STORAGE = None
    _DB_CACHE_DB = None
    
    @staticmethod
    def add_tg_alias(path: str, callback: Callable[[Intent], None]):
        if not isinstance(path, str) or not path: log("[MandreLib] Ошибка: путь для tg:// алиаса должен быть непустой строкой."); return
        _TG_ALIAS_MAP[path.rstrip('/')] = callback
        log(f"[MandreLib] Зарегистрирован tg:// алиас: {path}")
    
    @staticmethod
    def remove_tg_alias(path: str):
        if _TG_ALIAS_MAP.pop(path.rstrip('/'), None): log(f"[MandreLib] Удален tg:// алиас: {path}")

    @staticmethod
    def register_settings_alias(plugin_instance: BasePlugin):
        plugin_id = plugin_instance.id
        if not plugin_id: log("[MandreLib] Ошибка: у плагина нет ID."); return
        def open_settings_callback(intent: Intent):
            try:
                controller = PluginsController.getInstance()
                plugin = controller.plugins.get(plugin_id)
                fragment = get_last_fragment()
                if fragment and plugin: fragment.presentFragment(PluginSettingsActivity(plugin))
                else: BulletinHelper.show_error("Не удалось открыть настройки.")
            except Exception as e: log(f"[MandreLib] Ошибка при открытии настроек для {plugin_id}: {e}")
        Mandre.add_tg_alias(plugin_id, open_settings_callback)
        log(f"[MandreLib] Автоматически зарегистрирован алиас настроек: tg://{plugin_id}")

    @staticmethod
    def remove_settings_alias(plugin_instance: BasePlugin):
        if plugin_instance.id: Mandre.remove_tg_alias(plugin_instance.id); log(f"[MandreLib] Алиас настроек для {plugin_instance.id} удален.")
            
    @staticmethod
    def apply_and_refresh_settings(plugin_instance: BasePlugin):
        def refresher():
            try:
                PluginsController.getInstance().loadPluginSettings(plugin_instance.id)
                log(f"[MandreLib] Настройки для {plugin_instance.id} перезагружены через контроллер.")
            except Exception as e:
                log(f"[MandreLib] Критическая ошибка при обновлении настроек: {e}")
        run_on_ui_thread(refresher)
        
    @staticmethod
    def schedule_task(plugin_instance: BasePlugin, task_name: str, interval_seconds: int, callback: Callable):
        global _SCHEDULER_RUNNABLE
        if not callable(callback): log("[MandreLib] Ошибка: колбэк для задачи не является функцией."); return
        task_key = f"{plugin_instance.id}_{task_name}"
        with _TASK_LOCK:
            _TASKS[task_key] = {"cb": callback, "interval": max(1, int(interval_seconds)), "next_ts": time.time() + interval_seconds}
            log(f"[MandreLib] Задача '{task_key}' запланирована с интервалом {interval_seconds}с")
            if _SCHEDULER_RUNNABLE is None:
                _SCHEDULER_RUNNABLE = _SchedulerRunnable()
                _SCHEDULER_HANDLER.postDelayed(_SCHEDULER_RUNNABLE, 1000)
                log("[MandreLib] Планировщик запущен.")
        
    @staticmethod
    def cancel_task(plugin_instance: BasePlugin, task_name: str):
        global _SCHEDULER_RUNNABLE
        task_key = f"{plugin_instance.id}_{task_name}"
        with _TASK_LOCK:
            if _TASKS.pop(task_key, None):
                log(f"[MandreLib] Задача '{task_key}' отменена.")
            if not _TASKS and _SCHEDULER_RUNNABLE is not None:
                _SCHEDULER_HANDLER.removeCallbacks(_SCHEDULER_RUNNABLE)
                _SCHEDULER_RUNNABLE = None
                log("[MandreLib] Планировщик остановлен (нет задач).")

    @staticmethod
    def use_persistent_storage(plugin: BasePlugin):
        plugin_id = plugin.id
        if plugin_id in _PERSISTENT_PLUGINS or "_validation_test_" in plugin_id:
            return

        try:
            original_set_setting = plugin.set_setting
            def patched_set_setting(key, value):
                original_set_setting(key, value)
                if plugin_id not in _RESTORING_PLUGINS:
                    config = MandreData.read_persistent_json(plugin_id, "config.json", {})
                    config[key] = value
                    MandreData.write_persistent_json(plugin_id, "config.json", config)
            plugin.set_setting = patched_set_setting
            _PERSISTENT_PLUGINS.add(plugin_id)
            try:
                _RESTORING_PLUGINS.add(plugin_id)
                config = MandreData.read_persistent_json(plugin_id, "config.json", None)
                if config is not None:
                    log(f"[MandreLib] Восстановление настроек для {plugin_id} из персистентного хранилища.")
                    for key, value in config.items():
                        original_set_setting(key, value)
            finally:
                _RESTORING_PLUGINS.discard(plugin_id)
            log(f"[MandreLib] Персистентное хранилище настроек включено для {plugin_id}")
        except Exception:
            log(f"[MandreLib] Не удалось включить персистентное хранилище для {plugin_id}: {traceback.format_exc()}")
            
    @staticmethod
    def sql_get_database():
        try:
            storage = get_messages_storage()
            # Return cached DB if storage unchanged
            if getattr(Mandre, "_DB_CACHE_STORAGE", None) is storage and getattr(Mandre, "_DB_CACHE_DB", None):
                return Mandre._DB_CACHE_DB
            db = get_private_field(storage, "database")
            Mandre._DB_CACHE_STORAGE = storage
            Mandre._DB_CACHE_DB = db
            return db
        except Exception:
            return None

    @staticmethod
    def sql_init_kv(plugin_id: str, table_name: str = "mandre_kv"):
        try:
            db = Mandre.sql_get_database()
            if not db:
                return
            db.executeFast(f"CREATE TABLE IF NOT EXISTS {table_name} (plugin TEXT, k TEXT, v TEXT, PRIMARY KEY(plugin,k))").stepThis()
        except Exception:
            pass

    @staticmethod
    def sql_kv_set(plugin_id: str, key: str, value: Any, table_name: str = "mandre_kv"):
        try:
            db = Mandre.sql_get_database()
            if not db:
                return
            stmt = db.executeFast(f"REPLACE INTO {table_name} (plugin,k,v) VALUES (?,?,?)")
            try:
                stmt.bindString(1, str(plugin_id))
                stmt.bindString(2, str(key))
                stmt.bindString(3, str(value))
                stmt.stepThis()
            finally:
                try:
                    stmt.dispose()
                except Exception:
                    pass
        except Exception:
            pass

    @staticmethod
    def sql_kv_get(plugin_id: str, key: str, table_name: str = "mandre_kv") -> Optional[str]:
        try:
            db = Mandre.sql_get_database()
            if not db:
                return None
            cursor = db.queryFinalized(f"SELECT v FROM {table_name} WHERE plugin = '{plugin_id}' AND k = '{key}' LIMIT 1")
            try:
                if cursor.next():
                    try:
                        return cursor.stringValue(0)
                    except Exception:
                        try:
                            return str(cursor.intValue(0))
                        except Exception:
                            return None
            finally:
                try:
                    cursor.dispose()
                except Exception:
                    pass
        except Exception:
            pass
        return None

    @staticmethod
    def sql_kv_get_int(plugin_id: str, key: str, default: int = 0, table_name: str = "mandre_kv") -> int:
        v = Mandre.sql_kv_get(plugin_id, key, table_name)
        try:
            if v is None:
                return default
            if isinstance(v, int):
                return int(v)
            s = str(v).strip()
            if s.isdigit() or (s.startswith("-") and s[1:].isdigit()):
                return int(s)
        except Exception:
            pass
        return default

    @staticmethod
    def sql_kv_delete_prefix(plugin_id: str, prefix: str, table_name: str = "mandre_kv"):
        try:
            db = Mandre.sql_get_database()
            if not db:
                return
            stmt = db.executeFast(f"DELETE FROM {table_name} WHERE plugin = ? AND k LIKE ?")
            try:
                stmt.bindString(1, str(plugin_id))
                stmt.bindString(2, f"{prefix}%")
                stmt.stepThis()
            finally:
                try:
                    stmt.dispose()
                except Exception:
                    pass
        except Exception:
            pass

    @staticmethod
    def register_synthetic_channel(channel_id: int, title: str, megagroup: bool = False, broadcast: bool = True):
        try:
            mc = get_messages_controller()
            chat = mc.getChat(channel_id)
            if chat:
                if title and getattr(chat, 'title', None) != title:
                    chat.title = title
                    mc.putChat(chat, True)
                return chat
            channel = TLRPC.TL_channel()
            channel.id = int(channel_id)
            channel.title = title
            channel.megagroup = bool(megagroup)
            channel.broadcast = bool(broadcast)
            channel.creator = False
            channel.left = False
            channel.verified = False
            channel.scam = False
            channel.restricted = False
            mc.putChat(channel, True)
            return channel
        except Exception as e:
            log(f"[MandreLib] register_synthetic_channel error: {e}")
            return None
            
    @staticmethod
    def register_command(plugin_instance: BasePlugin, command_name: str, callback: Callable):
        if not callable(callback):
            log(f"[MandreLib] Ошибка регистрации команды '{command_name}': колбэк не является функцией.")
            return
        with _COMMAND_LOCK:
            _COMMANDS[command_name.lower()] = {
                "callback": callback,
                "plugin_instance": plugin_instance
            }
            log(f"[MandreLib] Команда '{command_name}' от плагина '{plugin_instance.id}' зарегистрирована.")
            
    @staticmethod
    def handle_outgoing_command(params: Any) -> Optional[HookResult]:
        global _mandrelib_instance
        if not _mandrelib_instance: return None

        msg = getattr(params, "message", None)
        if not isinstance(msg, str): return None
        
        prefix = _mandrelib_instance.get_setting("command_prefix", ".")
        if not msg.startswith(prefix): return None
        
        parts = msg[len(prefix):].split(' ', 1)
        cmd_name = parts[0].lower()
        args = parts[1] if len(parts) > 1 else ""
        
        with _COMMAND_LOCK:
            command_entry = _COMMANDS.get(cmd_name)
            
        if not command_entry: return None
        
        try:
            callback = command_entry["callback"]
            plugin_instance = command_entry["plugin_instance"]
            result = callback(plugin_instance, args, params)
            
            if isinstance(result, HookResult):
                return result
            if isinstance(result, str):
                params.message = result
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
            
            return HookResult(strategy=HookStrategy.CANCEL)
        except Exception:
            log(f"[MandreLib] Ошибка выполнения команды '{cmd_name}': {traceback.format_exc()}")
            BulletinHelper.show_error(f"Ошибка в команде .{cmd_name}")
            return HookResult(strategy=HookStrategy.CANCEL)

    @staticmethod
    def t(plugin_instance: BasePlugin, key: str, **kwargs) -> str:
        plugin_id = plugin_instance.id
        user_lang = LocaleController.getInstance().getCurrentLocaleInfo().getLangCode().split('-')[0]
        
        cache_key = f"{plugin_id}_{user_lang}"
        if cache_key in _LOCALIZATION_CACHE:
            translated_text = _LOCALIZATION_CACHE[cache_key].get(key)
            if translated_text:
                return translated_text.format(**kwargs) if kwargs else translated_text

        original_translations = _LOCALIZATIONS.get(plugin_id)
        if original_translations:
            original_text = original_translations.get(key, key)
            return original_text.format(**kwargs) if kwargs else original_text

        return key.format(**kwargs) if kwargs else key
        
    @staticmethod
    def register_localizations(plugin_instance: BasePlugin, source_lang: str, translations: Dict[str, str]):
        plugin_id = plugin_instance.id
        _LOCALIZATIONS[plugin_id] = translations
        
        user_lang = LocaleController.getInstance().getCurrentLocaleInfo().getLangCode().split('-')[0]
        
        cache_key = f"{plugin_id}_{user_lang}"
        if cache_key not in _LOCALIZATION_CACHE:
            cached_translation = MandreData.read_persistent_json(plugin_id, f"locales/{user_lang}.json")
            if cached_translation:
                _LOCALIZATION_CACHE[cache_key] = cached_translation
                log(f"[MandreLib AutoLoc] Загружен кэш локализации для {plugin_id} на {user_lang}.")

        if user_lang == source_lang:
            log(f"[MandreLib AutoLoc] Язык пользователя ({user_lang}) совпадает с языком плагина {plugin_id}. Перевод не требуется.")
            return
        
        offered_key = f"localization_offered_{plugin_id}_{user_lang}"
        if _mandrelib_instance and _mandrelib_instance.get_setting(offered_key, False):
            log(f"[MandreLib AutoLoc] Локализация для {plugin_id} на {user_lang} уже предлагалась.")
            return
            
        def start_flow():
            run_on_ui_thread(lambda: BulletinHelper.show_info(f"Обнаружен плагин {plugin_instance.name}. Предлагаю перевод на ваш язык..."))
            run_on_queue(lambda: Mandre._translation_worker(plugin_instance, user_lang, source_lang))

        threading.Timer(5.0, start_flow).start()

    @staticmethod
    def _translation_worker(plugin_instance, user_lang, source_lang):
        try:
            plugin_id = plugin_instance.id
            translations = _LOCALIZATIONS.get(plugin_id)
            if not translations:
                log(f"[MandreLib AutoLoc] Нет словаря для перевода плагина {plugin_id}.")
                return

            log(f"[MandreLib AutoLoc] Начало процесса перевода для {plugin_id} с {source_lang} на {user_lang}")
            
            values_to_translate = list(translations.values())
            translated_values_str = Mandre._call_pollinations_api_for_json(values_to_translate, user_lang)
            
            if not translated_values_str:
                log(f"[MandreLib AutoLoc] Не удалось получить перевод.")
                run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка перевода. Попробуйте позже."))
                return

            translated_values = json.loads(translated_values_str)
            if len(translated_values) != len(translations):
                 log(f"[MandreLib AutoLoc] Несоответствие количества переведенных строк.")
                 run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка формата перевода."))
                 return
            
            translated_dict = dict(zip(translations.keys(), translated_values))
            
            locale_dir_path = os.path.join(MandreData._get_base_data_dir().getAbsolutePath(), plugin_id, "locales")
            os.makedirs(locale_dir_path, exist_ok=True)
            
            MandreData.write_persistent_json(plugin_id, f"locales/{user_lang}.json", translated_dict)
            _LOCALIZATION_CACHE[f"{plugin_id}_{user_lang}"] = translated_dict
            log(f"[MandreLib AutoLoc] Локализация для {plugin_id} на {user_lang} сохранена.")
            
            if _mandrelib_instance:
                _mandrelib_instance.set_setting(f"localization_offered_{plugin_id}_{user_lang}", True)
                run_on_ui_thread(lambda: BulletinHelper.show_success("Перевод готов! Перезапустите плагин или приложение для применения."))

        except Exception:
            log(f"[MandreLib AutoLoc] Ошибка в translation_worker: {traceback.format_exc()}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Произошла ошибка во время перевода."))
    
    @staticmethod
    def _call_pollinations_api_for_json(values: List[str], target_lang: str) -> Optional[str]:
        try:
            lang_name = Locale(target_lang).getDisplayLanguage(Locale("en"))
            json_to_translate = json.dumps(values, ensure_ascii=False)
            
            prompt = (
                f"You are a translation assistant. Translate the following JSON array of strings into {lang_name}. "
                f"Your response must be ONLY a valid JSON array containing the translated strings in the exact same order. "
                f"Do not add any explanations, markdown, or other text outside of the JSON array. "
                f"Original JSON array:\n\n{json_to_translate}"
            )
            
            url = "https://text.pollinations.ai/openai"
            headers = {"Content-Type": "application/json"}
            payload = {
                "model": "mistral",
                "messages": [{"role": "user", "content": prompt}],
                "stream": False
            }

            response = requests.post(url, headers=headers, json=payload, timeout=90)
            response.raise_for_status()
            
            result = response.json()
            content = result.get("choices", [{}])[0].get("message", {}).get("content", "")
            
            match = re.search(r'\[\s*".*?"\s*(?:,\s*".*?"\s*)*\]', content, re.DOTALL)
            if match:
                return match.group(0)

            log("[MandreLib AutoLoc] Не удалось извлечь JSON массив из ответа API.")
            return None
        except Exception as e:
            log(f"[MandreLib AutoLoc] Ошибка API Pollinations: {e}")
            return None

class _ActivityResultHook(MethodHook):
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance
    def before_hooked_method(self, param):
        if param.args[0] == FILE_PICK_REQUEST_CODE:
            param.setResult(None)
            if param.args[1] == Activity.RESULT_OK and param.args[2] is not None:
                uri = param.args[2].getData()
                if uri:
                    run_on_queue(lambda: self.plugin._process_imported_file(uri, self.plugin._import_target_plugin_id))
            if self.plugin._activity_hook:
                self.plugin.unhook_method(self.plugin._activity_hook)
                self.plugin._activity_hook = None

class MandreLibPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._activity_hook = None
        self._import_target_plugin_id = None
        
    def on_plugin_load(self):
        global _mandrelib_instance
        _mandrelib_instance = self
        self.log(f"Библиотека '{self.name} v{self.version}' загружена.")
        _ensure_tg_hook(self)
        
    def on_plugin_unload(self):
        global _mandrelib_instance
        _internal_shutdown_tts() # Остановка TTS
        _mandrelib_instance = None
        self.log(f"Библиотека '{self.name} v{self.version}' выгружена.")

    def _create_data_management_fragment(self):
        items = [Header(text="Управление данными плагинов")]
        plugins_with_data = MandreData.list_persistent_plugins()
        if not plugins_with_data:
            items.append(Text(text="Нет сохраненных данных.", icon="msg_info_solar"))
            return items
        items.append(Text(text="Здесь хранятся данные и конфиги, которые не удаляются вместе с плагинами."))
        items.append(Divider())
        for plugin_id in plugins_with_data:
            items.append(Text(
                text=plugin_id,
                icon="files_folder_solar",
                create_sub_fragment=lambda p_id=plugin_id: self._create_plugin_data_fragment(p_id)
            ))
        return items

    def _create_plugin_data_fragment(self, plugin_id: str):
        files = MandreData.list_files_for_plugin(plugin_id)
        items = [Header(f"Данные для: {plugin_id}")]
        for filename in files:
            items.append(Text(text=filename, icon="msg_filehq_solar"))
        items.extend([
            Divider(),
            Text(
                text="Экспорт данных",
                icon="msg_upload_solar",
                accent=True,
                on_click=lambda _, p_id=plugin_id: self._handle_export_data(p_id)
            ),
            Text(
                text="Импорт данных",
                icon="msg_download_solar",
                accent=True,
                on_click=lambda _, p_id=plugin_id: self._handle_import_data(p_id)
            ),
            Text(
                text=f"Удалить все данные для {plugin_id}",
                icon="msg_delete",
                red=True,
                on_click=lambda _, p_id=plugin_id: MandreUI.show(
                    title="Подтверждение",
                    message=f"Вы уверены, что хотите удалить ВСЕ данные для плагина '{p_id}'? Это действие необратимо.",
                    items=["Да, удалить"],
                    on_select=lambda i, t: self._confirm_delete_data(p_id)
                )
            )
        ])
        return items
        
    def _confirm_delete_data(self, plugin_id: str):
        if MandreData.delete_persistent_plugin_data(plugin_id):
            BulletinHelper.show_success(f"Данные для {plugin_id} удалены.")
            Mandre.apply_and_refresh_settings(self) 
        else:
            BulletinHelper.show_error(f"Не удалось удалить данные.")
            
    def _handle_export_data(self, plugin_id: str):
        def _export_task():
            try:
                source_dir = File(MandreData._get_base_data_dir(), plugin_id)
                if not source_dir.exists() or not source_dir.isDirectory() or not source_dir.listFiles():
                    run_on_ui_thread(lambda: BulletinHelper.show_error("Нет данных для экспорта."))
                    return

                downloads_dir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
                if not downloads_dir.exists(): downloads_dir.mkdirs()
                
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                zip_filename = f"mandrelib_data_{plugin_id}_{timestamp}.zip"
                zip_path = os.path.join(downloads_dir.getAbsolutePath(), zip_filename)

                with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for filename in MandreData.list_files_for_plugin(plugin_id):
                        file_path = MandreData.get_persistent_path(plugin_id, filename)
                        zipf.write(file_path, arcname=filename)
                
                run_on_ui_thread(lambda: BulletinHelper.show_success(f"Данные экспортированы в Downloads/{zip_filename}"))
            except Exception as e:
                log(f"[MandreLib] Ошибка экспорта: {traceback.format_exc()}")
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка экспорта: {e}"))
        
        run_on_ui_thread(lambda: BulletinHelper.show_info("Экспорт данных..."))
        run_on_queue(_export_task)

    def _handle_import_data(self, plugin_id: str):
        try:
            self._import_target_plugin_id = plugin_id
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if not activity: BulletinHelper.show_error("Не удалось получить текущий экран."); return

            if self._activity_hook: self.unhook_method(self._activity_hook)
            
            method = activity.getClass().getDeclaredMethod("onActivityResult", JInteger.TYPE, JInteger.TYPE, Intent)
            self._activity_hook = self.hook_method(method, _ActivityResultHook(self))
            
            intent = Intent(Intent.ACTION_GET_CONTENT)
            intent.setType("application/zip")
            intent.addCategory(Intent.CATEGORY_OPENABLE)
            
            activity.startActivityForResult(Intent.createChooser(intent, "Выберите архив с данными"), FILE_PICK_REQUEST_CODE)
        except Exception as e:
            log(f"[MandreLib] Не удалось запустить выбор файла: {e}")
            BulletinHelper.show_error("Ошибка при открытии выбора файла.")

    def _process_imported_file(self, uri: Uri, plugin_id: str):
        run_on_ui_thread(lambda: BulletinHelper.show_info("Импорт данных..."))
        in_stream, out_stream = None, None
        try:
            context = ApplicationLoader.applicationContext
            resolver = context.getContentResolver()
            temp_dir = context.getCacheDir()
            temp_file = File(temp_dir, f"import_{plugin_id}.zip")
            
            in_stream, out_stream = resolver.openInputStream(uri), FileOutputStream(temp_file)
            buffer = bytearray(4096)
            bytes_read = in_stream.read(buffer)
            while bytes_read != -1:
                out_stream.write(buffer, 0, bytes_read)
                bytes_read = in_stream.read(buffer)
            
            MandreData.delete_persistent_plugin_data(plugin_id)
            target_dir = File(MandreData._get_base_data_dir(), plugin_id)
            if not target_dir.exists(): target_dir.mkdirs()
            
            with zipfile.ZipFile(temp_file.getAbsolutePath(), 'r') as zipf:
                zipf.extractall(target_dir.getAbsolutePath())
            
            temp_file.delete()
            
            run_on_ui_thread(lambda: (
                BulletinHelper.show_success(f"Данные для {plugin_id} импортированы!"),
                BulletinHelper.show_info("Перезапустите плагин для применения изменений.")
            ))
            Mandre.apply_and_refresh_settings(self)
        except Exception as e:
            error_message = f"Ошибка импорта: {e}"
            log(f"[MandreLib] {traceback.format_exc()}")
            run_on_ui_thread(lambda err=error_message: BulletinHelper.show_error(err))
        finally:
            try:
                if in_stream: in_stream.close()
                if out_stream: out_stream.close()
            except Exception as e_close:
                log(f"[MandreLib] Ошибка закрытия потока: {e_close}")
            
    def create_settings(self) -> List[any]:
        return [
            Header(text="Библиотека MandreLib"),
            Text(text="Надёжный фреймворк для ваших плагинов.", icon="msg_info_solar"),
            Divider(text="Команды"),
            Input(
                key="command_prefix",
                text="Префикс команд",
                subtext="Символ для активации команд в плагинах, использующих MandreLib.",
                default=".",
                icon="msg_edit_solar"
            ),
            Divider(text="Локализация"),
            Input(
                key="pollinations_api_key",
                text="API Key для Pollinations.AI (необязательно)",
                subtext="Используется для автоматического перевода плагинов. Можно оставить пустым.",
                default="",
                icon="ai_chat_solar"
            ),
            Divider(),
            Text(
                text="Управление данными плагинов",
                icon="menu_storage_path_solar",
                create_sub_fragment=lambda: self._create_data_management_fragment()
            )
        ]
